<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="generator" content="JsDoc Toolkit" />
		<title>Visual Novel Engine for HTML5 Canvas</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
		<meta name="mobileoptimized" content="0" />
	
		<link rel="stylesheet" href="css/all.css" media="all" />
		<link rel="stylesheet" href="css/handheld.css" media="only screen and (max-width: 660px)" />
		<link rel="stylesheet" href="css/handheld.css" media="handheld" />
		<link rel="stylesheet" href="css/screen.css" media="screen and (min-width: 661px)" />
	    <link rel="shortcut icon" href="favicon.ico" />    

		<script src="javascript/all.js"></script>
		<!--[if lt IE 9]>
			<script src="javascript/html5.js"></script>
		<![endif]-->
	</head>
	<body>

	<div class="index">
		<div class="menu">
			<div class="indexLinks">
				<a href="toc.html">Index</a>
				<a href="files.html">Files</a>
			</div>
			<h2 class="heading1">Navigation</h2>
			<input type="text" name="classFilter" class="classFilter" id="ClassFilter" placeholder="Filter"></input>
			<nav>
				<ul class="classList" id="ClassList">
					INTRODUCTION<br/>
					<li><a href="index.html">Intro</a></li>
					<li><a href="start.html">Getting started</a></li>
					<li><a href="config.html">Config file</a></li>
					<li><a href="plugins.html">Plug-ins</a></li>
					<li><a href="mods.html">Mod pack<span style="color:#C00000"> New!</span></a></li>
					<li><a href="demo.html">Demo</a></li>
					ELEMENTS<br/>
					<li><a href="actor.html">actor</a></li>
					<li><a href="atmosphere.html">atmosphere</a></li>
					<li><a href="audio.html">audio</a></li>
					<li><a href="box.html">box</a></li>
					<li><a href="menu.html">menu</a></li>
					<li><a href="overlay.html">overlay</a></li>
					<li><a href="scene.html">scene</a></li>
					<li><a href="text.html">text</a></li>
					<li><a href="video.html">video</a></li>
					FLOW CONTROL<br/>
					<li><a href="jump.html">jump</a></li>
					<li><a href="label.html">label</a></li>
					<li><a href="wait.html">wait</a></li>
					FORMS<br/>
					<li><a href="cform.html">cform</a></li>
					<li><a href="form.html">form</a></li>
					<li><a href="button.html">button</a></li>
					<li><a href="checkbox.html">checkbox</a></li>
					<li><a href="fieldset.html">fieldset</a></li>
					<li><a href="input.html">input</a></li>
					<li><a href="marquee.html">marquee</a></li>
					<li><a href="picture.html">picture</a></li>
					<li><a href="radio.html">radio</a></li>
					<li><a href="select.html">select</a></li>
					<li><a href="slider.html">slider</a></li>
					<li><a href="spinbox.html">spinbox</a></li>
					<li><a href="submit.html">submit</a></li>
					<li><a href="textarea.html">textarea</a></li>
					<li><a href="timer.html">timer</a></li>
					NAVIGATION<br/>
					<li><a href="automap.html">automap</a></li>					
					<li><a href="map.html">map</a></li>
					<li><a href="tile.html">tile</a></li>
					MISC<br/>
					<li><a href="animation.html">animation</a></li>
					<li><a href="checkpoint.html">checkpoint</a></li>
					<li><a href="get.html">get</a></li>
					<li><a href="set.html">set</a></li>
					<li><a href="macro.html">macro</a></li>
					<li><a href="preload.html">preload</a></li>
					<li><a href="screen.html">screen</a></li>
					DEBUGGING<br/>
					<li><a href="message.html">message</a></li>
				</ul>
			</nav>
		</div>
		<div class="fineprint" style="clear:both">
			<footer>
			<!--Documentation generator: <a href="http://code.google.com/p/jsdoc-toolkit/" target="_blank">JsDoc Toolkit</a> 2.4.0<br />-->
			Template: <a href="http://www.thebrightlines.com/2010/05/06/new-template-for-jsdoctoolkit-codeview/" target="_blank">Codeview</a> 
			for <a href="http://code.google.com/p/jsdoc-toolkit/" target="_blank">JsDoc Toolkit</a><br />		
			</footer>
		</div>
	</div>
	<div class="index indexStatic"></div>
	<div class="content">
		<div class="innerContent">
		<article>
			<header>
				<h1 class="classTitle"><span>Plug-ins</span></h1>	
				<div class="intro">
					<p class="description summary">
					Allows game-specific customization without modifying the engine.
						<ul class="summary">
							<li>Note: For advanced users. Javascript and canvas drawing knowledge required.</li>
							<li>Currently supports Transitions and Atmospheric effects, and Canvas Form elements.</li>
							<li><span style="color:#C00000">Update:</span> Now supports character stats.</li>
						</ul>					
					</p>
				</div>
			</header>
			<section>
				<div class="details props">
					<div class="innerProps">
						<h2 class="sectionTitle">Atmospheric Effects</h2>
						<ul class="summary">
							<li>Want to define a custom atmospheric effect? Then add an atmospheric
							effect plug-in. First, start with a template code snippet.
								<pre class="code">  
AtmoEffects.<span style="color:#00C000">my_custom_atmo</span> = {
  _init: function(obj, param) {
    // Place initialization here
  },
  _update: function(obj, elapsed) {
    // Place update code here
  },
  _draw: function(obj) {
    // Place draw code here
  },
};
								</pre></li><br/>
							<li><i>my_custom_atmo</i> is the name of your custom atmospheric effect.</li>
							<li><i>_init</i> method is called once to perform specific initialization.</li> 
							<li><i>_update</i> method is called every frame.</li>
							<li><i>_draw</i> method is called if a redraw is necessary.</li>
							<li><i>obj</i> is a reference to the atmosphere object.</li>
							<li><i>elapsed</i> is the amount of time in milliseconds since last update.</li>
							<li><i>param</i> refers to the parameters as entered in the script line.</li><br/>
							<li>Before continuing, it is necessary to know the following variables common to all
								atmospheric effects. Your custom effect may use any of these variables. To access
								these variables, don't forget to use 'this'.
								<pre class="code">
action:		usually 'start' or 'stop'
alpha:		the opacity of the drawn elements (from 0.0 or transparent to 1.0 or opaque).
context:	the canvas context to draw on to.
isready:	true means the effect has completed initialization. If loading images, for
		example, set this initially to false, then set it to true once the image has loaded.
redraw:		true means that a redraw is necessary. 
saveparam:	custom object used for game saves. This will be used as the parameters when the
		effect is loaded during game load. By default, this is the same as the parameter when
		the effect is invoked in the scriptline.
type: 		the type of effect (usually the effect name).
update:		false pauses update of the stage while the effect is drawing. Default is always true.
visible:	if false, effect is not drawn.
								</pre></li><br/>
							<li>As an example, let's define a custom effect named 'sample_atmo_fx' that
								just displays an image. (The sample shown is a simplified code. For the 
								default effects, see engine code.)
								<pre class="code">  
AtmoEffects.<span style="color:#00C000">sample_atmo_fx</span> = {
  _init: function(obj, param) {
    <span style="color:#00C000">obj.isready = false;
    // define a new image element
    obj.image = new Image();	
    obj.src = param.sample_atmo_fx;
    obj.image.onload = function() {
      obj.isready = true;
    };
    obj.image.src = this.src;
	
    // the effect is invoked with another parameter sample_arg
    obj.sample_arg = param.sample_arg;</span>
  },
  _update: function(obj, elapsed) {
    <span style="color:#00C000">if (obj.action == 'stop') {
      // do some updates here to stop the effect
      // if stopping made the effect invisible
      obj.visible = false;
    }
    else {
      // do some updates here to update the effect
      obj.redraw = true;		// a redraw is needed
    }</span>
  },
  _draw: function(obj) {
    <span style="color:#00C000">// effect is drawn if isready and redraw are true
    obj.context.drawImage(this.image, 0, 0);</span>
  },
};
								</pre></li><br/>
							<li>As with macros, it is recommended that all plug-ins be placed in one file,
								then added in TOC.
								<pre class="code">  
TOC = [
	<span style="color:#00C000">"include/config.js",
	"include/plugins.js",
	
	"include/story-prelude.js",
	"include/story-chapter1.js",
	"include/story-chapter2.js",
	"include/story-chapter3.js",
	"include/story-chapter4.js"</span>
];
								</pre></li><br/>
							<li>Finally to invoke the custom atmosphere, see 'atmosphere' keyword.
								<pre class="code">  
chapter = [

	...
	/* the first parameter must be the atmosphere effect */
	atmosphere, {sample_atmo_fx:"image.png", sample_arg:dummy},
	...
];
								</pre></li><br/>
						</ul>
					</div>
				</div>
			</section>
			<section>
				<div class="details props">
					<div class="innerProps">
						<h2 class="sectionTitle">Transition Effects</h2>
						<ul class="summary">
							<li>Transition effects are used by actors, overlay and scene images.
								Unlike atmospheric effects, these are methods called within the Update()
								method of an object.<br/>
								First, start with a template code snippet.
								<pre class="code">  
TransEffects.<span style="color:#00C000">my_custom_fx</span> = {
  _init: function(obj, param) {
    // Place initialization here
  },
  _in: function(obj, elapsed) {
    // Place show transition code here
  },
  _out: function(obj, elapsed) {
    // Place hide transition code here
  },
};
								</pre></li><br/>
							<li><i>my_custom_fx</i> is the name of your custom transition effect.</li>
							<li><i>_init</i> method is called once to perform specific initialization. This is optional.</li>
							<li><i>_in</i> method is called every frame for showing transitions (such as fade-in).</li>
							<li><i>_out</i> method is called every frame for hiding transitions (such as fade-out).</li>
							<li><i>obj</i> is the object calling the transtion.</li>
							<li><i>elapsed</i> is the time in milliseconds since last update.</li>
							<li><i>param</i> is an array of parameters depending on the effect.</li><br/>
							<li>Before continuing, it is necessary to know the following variables common to 
								applicable objects. Your custom effect may use any of these variables. These
								variables are passed thru the 'obj' parameter.
								<pre class="code">
alpha:		the object's opacity (from 0.0 to 1.0)
drawn:		this indicates that the effect has finished drawing. Use this to control script updates.
		If set to true while the effect is ongoing, the next line of script is executed even when the
		transition is ongoing. If set to true at the end of transition, the next line of script is
		executed only at end of transition.
effects:	the active transition effect. Set this to 'done' once the effect is finished.
pos:		the object's vector position (x and y coordinates are pos.vx and pos.vy, respectively)
target_pos:	the object's target vector position
redraw:		true means that a redraw is necessary.
rotation:	the object is rotated using this (default is 0).
scale:		the object is scaled using this (default is 1.0).
visible:	if false, the object is not drawn.
wait:		if true, wait for effect to complete before proceeding. See also 'drawn'.
								</pre></li><br/>
							<li>As an example, let's define a custom effect named 'translate' that
								moves the object from its current position. (The sample below is a
								simplified version of actual translate effect. For more of the 
								default effects, see engine code.)
								<pre class="code">  
TransEffects.<span style="color:#00C000">translate</span> = {
  _init: function(obj, param) {
    <span style="color:#00C000">//offset the target position based on parameter given
    obj.target_pos.vx += parseFloat(param[0]);
    obj.target_pos.vy += parseFloat(param[1]);</span>
  },
  _in: function(obj, elapsed) {
    <span style="color:#00C000">//start the effect
    obj.visible = true;
    obj.redraw = true;
    if (!obj.wait) obj.drawn = true;
    obj.alpha = 1.0;
    if (/* place end condition here */) {
      obj.effects = 'done';
      obj.drawn = true;
    }
    else {
      // perform translation here
    }</span>
  },
  _out: function(obj, elapsed) {
    <span style="color:#00C000">//translate_out doesn't actually make sense
    //just hide the object
    obj.alpha = 0.0;
    obj.visible = false;
    obj.effects = 'done';
    obj.drawn = true;
    obj.redraw = true;</span>
  },
};
								</pre>
							</li><br/>
							<li>As with macros, it is recommended that all plug-ins be placed in one file,
								then added in TOC.
								<pre class="code">  
TOC = [
	<span style="color:#00C000">"include/config.js",
	"include/plugins.js",
	
	"include/story-prelude.js",
	"include/story-chapter1.js",
	"include/story-chapter2.js",
	"include/story-chapter3.js",
	"include/story-chapter4.js"</span>
];
								</pre>
							</li><br/>
							<li>Finally to invoke the custom transition effect, see corresponding object keyword.
								<pre class="code">  
chapter = [

	...
	/* this creates an overlay and moves it 100px to the right
	and down relative to current position (which is center
	by default */
	overlay, {src:"image.png", effect:"translate 100 100"},
	...
];
								</pre>
							</li><br/>
						</ul>
					</div>
				</div>
			</section>
			<section>
				<div class="details props">
					<div class="innerProps">
						<h2 class="sectionTitle">Canvas Forms Elements</h2>
						<ul class="summary">
							<li>Canvas forms provide a way to implement graphical interface to the player.
								The engine supports 'button' (which can also be used as a simple label or
								a clickable image map), 'picture' and 'timer'. But not all games are the same.
								What if you need to add a custom element?<br/>
								First, start with a template code snippet. Note the similarity with AtmoEffects.
								<pre class="code">  
CformElements.<span style="color:#00C000">my_custom_element</span> = {
  _init: function(obj, param) {
    // Place initialization here
  },
  _update: function(obj, elapsed) {
    // Place update code here
  },
  _draw: function(obj) {
    // Place draw code here
  },
};
								</pre></li><br/>
							<li><i>my_custom_fx</i> is the name of your custom cform element.</li>
							<li><i>_init</i> method is called once to perform specific initialization.</li>
							<li><i>_update</i> method is called every frame.</li>
							<li><i>_draw</i> method is called if a redraw is necessary.</li>
							<li><i>obj</i> is a reference to the cform element.</li>
							<li><i>elapsed</i> is the time in milliseconds since last update.</li>
							<li><i>param</i> refers to the parameters as entered in the script line.</li><br/>
							<li>Before continuing, it is necessary to know the following variables common to 
								cform elements. Your custom effect may use any of these variables. These
								variables are passed thru the 'obj' parameter. Of course, you can also use
								custom variables if any.<br/>
								Note also that all cform elements belong to the ActiveImage class. The ActiveImage
								class handles the creation of the drawable elements, so you don't need to worry
								about it when making the custom element.
								<pre class="code">
type:		the type of element
link:		the link to follow or execute, if present
sprites:	array containing the image objects of the element
showText:	determines if the text of the element is displayed
timeout:	if element is timed, this sets the duration
redraw:		true means that a redraw is necessary.
saveparam:	custom object used for game saves. This will be used as the parameters when the
		cform element is loaded during game load. By default, this is the same as the 
		parameter when the element is invoked in the scriptline.
								</pre></li><br/>
							<li>In addition, you may need to know two methods of the ActiveImage class.
								<pre class="code">
Create(id, rect, obj)	: handles creation of the cform element
			: <i>id</i> is the identifier of the cform element
			: <i>rect</i> is the dimensions of the cform element (see Rect class). If image based, w and h are ignored.
			: <i>obj</i> is the array of image sprites or fillstyle for the cform element. 
DrawImageOrFill(object)	: handles drawing or filling the cform element
			: <i>object</i> is usually an element of the 'obj' array
								</pre></li><br/>
							<li>As an example, let's define a custom element named 'progressBar' that reflects
								the value of a user variable. (see Timed Test for live demo)
								<pre class="code">  
CformElements.<span style="color:#00C000">progressBar</span> = {
  _init: function(obj, param) {
    <span style="color:#00C000">//create the progressBar appearance
    var rect = {x:param.x, y:param.y, w:param.w, h:param.h};
    var sprites = ['gray', 'orange'];
    obj.Create(param.name, rect, sprites);
    // note: param.name can now be accessed as obj.id
    
    // set user variable for the progress bar value
    // user variable with id=param.name must be created beforehand
    obj.timeout = param.timeout;
    Helper.setValue(param.name, obj.timeout);
    </span>
  },
  _update: function(obj, elapsed) {
    <span style="color:#00C000">//create a 1 second timer
    if (!obj.aTimerOn) {
      this.aTimer = setTimeout(function() {
        // decrement timeout counter
        Helper.setValue(obj.id, Helper.getValue(obj.id)-1);
        obj.redraw = true;
        if (Helper.getValue(obj.id) > 0)
          obj.aTimerOn = false;
      }, 1000 );
      obj.aTimerOn = true;
    }</span>
  },
  _draw: function(obj) {
    <span style="color:#00C000">//draw progressBar back
    obj.DrawImageOrFill(obj.sprites[0]);
    // manually draw the progress bar since this is scaled
    var scale = (obj.timeout - Helper.getValue(obj.id))/obj.timeout;
    obj.context.fillStyle = obj.sprites[1];
    obj.context.fillRect(0,0, scale*obj.context.canvas.width, obj.context.canvas.height);</span>
  },
};
								</pre>
							</li><br/>
							<li>As with macros, it is recommended that all plug-ins be placed in one file,
								then added in TOC.
								<pre class="code">  
TOC = [
	<span style="color:#00C000">"include/config.js",
	"include/plugins.js",
	
	"include/story-prelude.js",
	"include/story-chapter1.js",
	"include/story-chapter2.js",
	"include/story-chapter3.js",
	"include/story-chapter4.js"</span>
];
								</pre>
							</li><br/>
							<li>Finally to invoke the custom canvas form element (inside a 'cform' call), use the
								'cfelement' keyword. The only required parameters are 'type' which identifies the type
								of cform element and 'name' which is the id of the cform element. The rest depends on 
								how we choose to implement the custom element.
								<pre class="code">  
chapter = [
	...
	set, {Waiting:0},
	...
	cfelement, {type:"progressBar", 
		    name:"Waiting", 
		    x:260, y:300, w:200, h:20, 
		    timeout:10},
	...
];
								</pre>
							</li><br/>
						</ul>
					</div>
				</div>
			</section>
			<section>
				<div class="details props">
					<div class="innerProps">
						<h2 class="sectionTitle">Character Stats</h2>
						<ul class="summary">
							<li>Character stats add another dimension to your characters. If you're going
								for RPG-like characters, you may want to add stats like level, strength, agility,
								etc. If you want character inter-personal development, you may want to add stats
								like personality, relationship, etc.<br/>
								Since the options are limitless, this plug-in merely lets you define a base set of
								stats applicable to all actors you define in the game. How you'd use the stat in the game
								or how you let it grow or how you'd define a custom stat for a specific actor depends
								entirely up to you. You may need use of 'macro' or custom scripting.<br/>
								First, start with the stats attribute objects. 
								<pre class="code">  
Stats.<span style="color:#00C000">attribute</span> = {
  _value: [],
  _update: function(obj, stat) {
  },
};
								</pre></li><br/>
							<li>The '_value' array specifies the list of allowable values.<br/>
								If the attribute is numerical, specify a min-max range.<br/>
								If the attribute is boolean, specify true or false.<br/>
								If the attribute is string, enumerate the string values.<br/>
								The first entry is the default value of the attribute.
								<pre class="code">
Stats.<span style="color:#00C000">attrNumber</span> = {
  _value: [<span style="color:#00C000">0, 100</span>],
  _update: function(obj, stat) {
  },
};
Stats.<span style="color:#00C000">attrBoolean</span> = {
  _value: [<span style="color:#00C000">true, false</span>],
  _update: function(obj, stat) {
  },
};
Stats.<span style="color:#00C000">attrString</span> = {
  _value: [<span style="color:#00C000">"string1", "string2", "string3"</span>],
  _update: function(obj, stat) {
  },
};
								</pre></li><br/>
							<li>Of course, you might want to use more descriptive attribute names.</li><br/>
							<li>Oftentimes, stats are not unrelated, i.e. one stat affects the others. For example,
								increasing character's strength may mean loss of agility, or increase in affection to
								one actor may mean a decrease to other actors. To support this, use the optional '_update'
								method to add these custom functionality.
								<pre class="code">
Stats.<span style="color:#00C000">attrNumber1</span> = {
  _value: [<span style="color:#00C000">0, 100</span>],
  _update: function(obj, stat) {
    <span style="color:#00C000">/* obj is the actor object */
    /* stat is the actor's attributes */
    if (stat.attrNumber1 > 50)
      stat.attrNumber2 -= 10;
    /* make sure though that attrNumber2 value is still valid */</span>
  },
};
								</pre></li><br/>
							<li>Next add that to the plugins file, which should be then added in TOC.
								<pre class="code">  
TOC = [
	<span style="color:#00C000">"include/config.js",
	"include/plugins.js",
	
	"include/story-prelude.js",
	"include/story-chapter1.js",
	"include/story-chapter2.js",
	"include/story-chapter3.js",
	"include/story-chapter4.js"</span>
];
								</pre>
							</li><br/>
							<li>When you create your actors, these stats will be automatically created for the
								character using the default values. There's no need to explicitly create/set
								the attributes, unless it is different from the default.
								<pre class="code">  
chapter = [
	...
	actor, {id:"actor1", sprite:["normal", "images/actor1-normal.png"], ... },
	/* the stats are automatically added at this point */
	...
];
								</pre>
							</li><br/>
							<li>To set or update a character stat, use 'set' as you would use for a user variable.
								The name of the variable, in this case, is 'actorId_attrName'. Unlike user variables
								though, character stats are checked with the Stats object if valid (e.g. within range,
								string value is an element of the enumeration, etc.). Also, except for numerical attributes,
								the element index may be specified instead of the value (e.g. to set attrString to 'string3',
								you can specify 'attrString:2' to set to element at index 2).
								<pre class="code">  
chapter = [
	...
	actor, {id:"actor1", sprite:["normal", "images/actor1-normal.png"], ... },
	/* the stats are automatically added at this point */
	...
	/* this adds 1 to attrNumber for actor1
	set, {actor1_attrNumber:"+1"},
	...
];
								</pre>
							</li><br/>
							<li><span style="color:#C00000">Update:</span>You may use "random" for numerical attributes, but
							there's no need to specify a min-max range. The value is automatically computed using the
							'_value' range specified for the attribute.</li><br/>
							<li>To use actor stats for flow control, you can use conditional 'jump' just as you
								would a user variable.
								<pre class="code">  
chapter = [
	...
	jump, {actor1_attrNumber:10, label:"go_to_level10"},
	/* attrNumber is less than 10 here */
	...
	label, "go_to_level10",
	/* attrNumber is greater than or equal to 10 here */
	...
];
								</pre>
							</li><br/>
						</ul>
					</div>
				</div>
			</section>
		</article>
		</div>
	</div>
	<script type="text/javascript">
		wbos.CssTools.MediaQueryFallBack.LoadCss('css/screen.css', 'css/handheld.css', 660)
		codeview.classFilter.Init()
	</script>
	
	</body>
</html>

